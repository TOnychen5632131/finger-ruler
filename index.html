<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>指甲宽度测量（移动端网页）</title>
  <style>
    :root{
      --bg:#0b1020;          /* 深色背景，利于户外/强光可读 */
      --card:#121a33;
      --card-2:#0f1730;
      --text:#e9eefb;
      --muted:#a7b0c6;
      --accent:#6aa7ff;
      --accent-2:#3a7cff;
      --ok:#2ecc71;
      --warn:#f1c40f;
      --err:#ff5c6c;
      --pill:#0e1428cc;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; }
    html,body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: -apple-system, SF Pro Text, Inter, Roboto, "Helvetica Neue", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      touch-action:none; overscroll-behavior: none; user-select:none;
    }

    /* 顶部栏 */
    header{
      position: sticky; top:0; z-index:30; backdrop-filter: saturate(1.2) blur(6px);
      background: linear-gradient(180deg, rgba(10,15,30,.95), rgba(10,15,30,.75));
      padding: env(safe-area-inset-top) 14px 10px 14px; box-shadow: var(--shadow);
    }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    h1{ font-size:18px; margin:0 8px 0 0; letter-spacing:.4px; }
    .chip{
      font-size:12px; color:var(--muted); padding:6px 10px; border-radius:999px; background: #121a33;
      border:1px solid #1c274d; display:inline-flex; align-items:center; gap:6px;
    }
    .chip b{ color:var(--text); font-weight:600; }
    .btn{
      appearance:none; outline:0; border:1px solid #2a3563; color:var(--text);
      background:linear-gradient(180deg,#1a2447,#141d3b); padding:8px 12px; border-radius:12px;
      font-size:13px; font-weight:600; box-shadow: var(--shadow);
      display:inline-flex; align-items:center; gap:8px; cursor:pointer;
      transition: transform .06s ease;
    }
    .btn:active{ transform: scale(.98); }

    /* 首屏提示 */
    #hint{ text-align:center; padding:28px 18px 14px; color:var(--muted); font-size:14px; }

    /* 测量覆盖层与画布 */
    #overlay{ position:fixed; inset:0; z-index:20; pointer-events:none; }
    #rulerCanvas{ position:absolute; width:320px; height:140px; box-shadow: var(--shadow);
      border-radius:16px; background:linear-gradient(180deg,#0c142d,#0a1124); border:1px solid #1b2550; }

    /* 结果 pill */
    #resultPill{
      position: fixed; left:50%; transform: translateX(-50%);
      bottom: calc(16px + env(safe-area-inset-bottom));
      background: var(--pill); color: var(--text); border:1px solid #243165;
      padding: 10px 14px; border-radius: 999px; font-weight:700; font-size:14px; z-index:40;
      display:flex; align-items:center; gap:10px; box-shadow: var(--shadow);
    }
    

    /* 手动双把手模式 */
    #manualWrap{ position:absolute; pointer-events:auto; padding:10px 12px; width:320px; }
    .bar{ position:relative; height:32px; border-radius:10px; background:#0b1430; border:1px solid #283466; }
    .handle{ position:absolute; top:0; width:28px; height:32px; border-radius:8px; background:#132252; border:1px solid #3551a3; box-shadow: var(--shadow); touch-action: none; }
    .handle::after{ content:""; position:absolute; left:50%; top:6px; bottom:6px; width:3px; transform:translateX(-50%);
      background:linear-gradient(180deg,#4a79ff,#7aa5ff); border-radius:2px; }

    /* 模态框通用 */
    .modal{ position:fixed; inset:0; display:none; z-index:50; }
    .modal.show{ display:block; }
    .backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); }
    .sheet{ position: absolute; left:0; right:0; bottom:0; border-top-left-radius:18px; border-top-right-radius:18px;
      background:linear-gradient(180deg,#111a35,#0b1229); border-top:1px solid #243165; box-shadow: var(--shadow);
      padding:16px 14px calc(18px + env(safe-area-inset-bottom)); }
    .sheet h3{ margin:6px 4px 8px; font-size:15px; }
    .field{ margin:12px 6px; color:var(--muted); font-size:12px; }
    .field input[type="range"], .field input[type="number"]{ width:100%; }
    .row-between{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: #cbd7ff; }
    .tip{ font-size:12px; color:#9eb0d6; }

    /* 校准中的银行卡框 */
    #cardBox{ height:54mm; /* 任意高度用于对齐参照，宽度由 JS 控制为 85.60mm 等效像素 */
      border:2px dashed #3a7cff; border-radius:10px; background: rgba(58,124,255,.05); margin:8px 0 12px; }

    /* 手机限定提示 */
    #mobileOnly{ position:fixed; inset:0; z-index:60; display:none; align-items:center; justify-content:center; text-align:center; padding:24px; background: #0b1020; }
    #mobileOnly.show{ display:flex; }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <h1>指甲宽度测量</h1>
      <span class="chip">校准×<b id="chipScale">0.83</b>｜比例×<b id="chipRatio">0.68</b></span>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnCalib">校准（银行卡 85.60mm）</button>
      <button class="btn" id="btnRatio">指甲比例（0.50–0.90）</button>
      <button class="btn" id="btnRules">尺码规则（S/M 可调）</button>
      <button class="btn" id="btnMode">切换模式：<span id="modeText">触点</span></button>
    </div>
  </header>

  <div id="hint">轻压屏幕任意位置开始测量。尺子会在手指正上方显示。为更准确，请先在菜单中完成银行卡宽度校准。</div>

  <div id="overlay">
    <canvas id="rulerCanvas" width="640" height="280" aria-hidden="true"></canvas>
    <!-- 手动模式控件（位置由 JS 放置到触点上方） -->
    <div id="manualWrap" style="display:none">
      <div class="bar" id="manualBar">
        <div class="handle" id="hLeft" style="left:20px"></div>
        <div class="handle" id="hRight" style="left:260px"></div>
      </div>
      <div class="tip" style="margin-top:8px">拖动左右把手对齐指甲两侧</div>
    </div>
  </div>

  <div id="resultPill">
    <span id="pillText">—.— mm • 尺码 —</span>
  </div>

  <!-- 模态框：校准 -->
  <div class="modal" id="modalCalib" role="dialog" aria-modal="true">
    <div class="backdrop" data-close="#modalCalib"></div>
    <div class="sheet">
      <h3>校准：使下方虚线框与真实银行卡宽度对齐</h3>
      <div id="cardBox"></div>
      <div class="row-between"><div class="tip">目标：85.60 mm</div><div class="mono">scale=<span id="scaleLabel">0.83</span></div></div>
      <div class="field">
        <input id="scaleRange" type="range" min="0.60" max="1.20" step="0.01" value="0.83">
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" data-close="#modalCalib">完成</button>
        <button class="btn" id="resetScale">恢复默认 0.83</button>
      </div>
    </div>
  </div>

  <!-- 模态框：比例 -->
  <div class="modal" id="modalRatio" role="dialog" aria-modal="true">
    <div class="backdrop" data-close="#modalRatio"></div>
    <div class="sheet">
      <h3>指甲/手指宽度比例</h3>
      <div class="tip">默认 0.68，可在 0.50–0.90 之间按反馈调优</div>
      <div class="row-between" style="margin-top:8px"><div></div><div class="mono">ratio=<span id="ratioLabel">0.68</span></div></div>
      <div class="field"><input id="ratioRange" type="range" min="0.50" max="0.90" step="0.01" value="0.68"></div>
      <div class="row" style="margin-top:10px"><button class="btn" data-close="#modalRatio">完成</button></div>
    </div>
  </div>

  <!-- 模态框：尺码规则 -->
  <div class="modal" id="modalRules" role="dialog" aria-modal="true">
    <div class="backdrop" data-close="#modalRules"></div>
    <div class="sheet">
      <h3>尺码规则（单位：mm）</h3>
      <div class="row" style="gap:12px; margin-top:8px">
        <div class="field" style="flex:1">
          <label>S（默认15）</label>
          <input id="sInput" type="number" step="0.1" min="10" max="25" value="15">
        </div>
        <div class="field" style="flex:1">
          <label>M（默认16）</label>
          <input id="mInput" type="number" step="0.1" min="10" max="25" value="16">
        </div>
        <div class="field" style="flex:1">
          <label>L（可选，默认17）</label>
          <input id="lInput" type="number" step="0.1" min="10" max="30" value="17">
        </div>
      </div>
      <div class="tip" style="margin-top:6px">分界按中点法：S/M=(S+M)/2，M/L=(M+L)/2</div>
      <div class="row" style="margin-top:12px">
        <button class="btn" data-close="#modalRules">完成</button>
        <button class="btn" id="resetRules">恢复默认 15/16/17</button>
      </div>
    </div>
  </div>

  <!-- 手机限定提示（在桌面提示） -->
  <div id="mobileOnly">
    <div>
      <h2 style="margin:0 0 8px">此页面仅支持手机端触摸测量</h2>
      <div class="tip">请用 iPhone（Safari）或 Android 手机（Chrome）打开本页。您仍可在顶部菜单完成参数设置与预览。</div>
    </div>
  </div>

  <script>
  ;(() => {
    // ================================
    // 配置与持久化
    // ================================
    const store = {
      get k(){ return {
        scale: 'mm_scale', ratio: 'nail_ratio', s:'rule_s', m:'rule_m', l:'rule_l'
      }},
      get scale(){ return +(localStorage.getItem(this.k.scale) ?? 0.83) },
      set scale(v){ localStorage.setItem(this.k.scale, v) },
      get ratio(){ return +(localStorage.getItem(this.k.ratio) ?? 0.68) },
      set ratio(v){ localStorage.setItem(this.k.ratio, v) },
      get S(){ return +(localStorage.getItem(this.k.s) ?? 15) },
      set S(v){ localStorage.setItem(this.k.s, v) },
      get M(){ return +(localStorage.getItem(this.k.m) ?? 16) },
      set M(v){ localStorage.setItem(this.k.m, v) },
      get L(){ return +(localStorage.getItem(this.k.l) ?? 17) },
      set L(v){ localStorage.setItem(this.k.l, v) },
    }

    // ================================
    // 运行时度量 px/mm
    // ================================
    let pxPerInch = 96; // 浏览器默认，初始化后会重新测量
    let pxPerMMBase = pxPerInch / 25.4;
    const measure1In = () => {
      const el = document.createElement('div');
      el.style.position = 'absolute';
      el.style.left = '-9999px';
      el.style.top = '-9999px';
      el.style.width = '1in';
      el.style.height = '1in';
      document.body.appendChild(el);
      const r = el.getBoundingClientRect();
      document.body.removeChild(el);
      return r.width || 96;
    }
    const refreshPxBase = () => {
      pxPerInch = measure1In();
      pxPerMMBase = pxPerInch / 25.4;
      // 更新校准预览框
      updateCardBoxWidth();
    }

    // ================================
    // DOM refs
    // ================================
    const $ = sel => document.querySelector(sel);
    const canvas = $('#rulerCanvas');
    const ctx = canvas.getContext('2d', { desynchronized: true });
    const overlay = $('#overlay');
    const pill = $('#pillText');
    const hint = $('#hint');
    const chipScale = $('#chipScale');
    const chipRatio = $('#chipRatio');

    // Modals & controls
    const modalCalib = $('#modalCalib');
    const scaleRange = $('#scaleRange');
    const scaleLabel = $('#scaleLabel');
    const cardBox = $('#cardBox');

    const modalRatio = $('#modalRatio');
    const ratioRange = $('#ratioRange');
    const ratioLabel = $('#ratioLabel');

    const modalRules = $('#modalRules');
    const sInput = $('#sInput');
    const mInput = $('#mInput');
    const lInput = $('#lInput');

    const btnCalib = $('#btnCalib');
    const btnRatio = $('#btnRatio');
    const btnRules = $('#btnRules');
    const btnMode = $('#btnMode');
    const modeText = $('#modeText');

    // 手动模式控件
    const manualWrap = $('#manualWrap');
    const manualBar = $('#manualBar');
    const hLeft = $('#hLeft');
    const hRight = $('#hRight');

    // 手机限定提示
    const mobileOnly = $('#mobileOnly');

    // ================================
    // 状态
    // ================================
    let measuring = false;
    let manualMode = false; // 双把手模式
    let lastSample = { x: 0, y: 0, w: 0 };
    let zeroFrameCount = 0; // 连续 0 宽计数，用于自动切换手动模式

    // 中值滤波队列（3 帧）
    const smoothN = 3;
    const mmQueue = [];

    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

    function resizeCanvas(){
      const cssW = parseFloat(getComputedStyle(canvas).width);
      const cssH = parseFloat(getComputedStyle(canvas).height);
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function pxPerMM(){
      return pxPerMMBase * store.scale;
    }

    function updateChips(){
      chipScale.textContent = store.scale.toFixed(2);
      chipRatio.textContent = store.ratio.toFixed(2);
    }

    function updateCardBoxWidth(){
      const wPx = 85.60 * pxPerMM();
      cardBox.style.width = Math.max(50, Math.min(window.innerWidth - 28, wPx)) + 'px';
    }

    // ================================
    // 采样与事件
    // ================================
    function feedSample(x, y, w){
      lastSample = { x, y, w };
      placeAbove(x, y);
      }

    function placeAbove(x, y){
      const pad = 16;
      const offsetY = 170; // 将尺子放在触点上方 170px 左右
      const left = Math.min(Math.max(8, x - 160), window.innerWidth - 320 - 8);
      const top = Math.max(8 + (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-top)'))||0), y - offsetY);
      canvas.style.left = left + 'px';
      canvas.style.top = top + 'px';

      manualWrap.style.left = left + 'px';
      manualWrap.style.top = (top + canvas.getBoundingClientRect().height + 6) + 'px';
    }

    // 指针事件
    let pointerActive = false;
    document.addEventListener('pointerdown', (e) => {
      pointerActive = true;
      measuring = true; zeroFrameCount = 0; hint.style.display = 'none';
      const w = e.width || 0; feedSample(e.clientX, e.clientY, w);
      e.preventDefault();
    }, { passive: false });
    document.addEventListener('pointermove', (e) => {
      if(measuring && pointerActive && !manualMode){
        const w = e.width || 0; feedSample(e.clientX, e.clientY, w);
        e.preventDefault();
      }
    }, { passive: false });
    ['pointerup','pointercancel','pointerout','pointerleave'].forEach(type => {
      document.addEventListener(type, () => { pointerActive=false; measuring=false; }, { passive:true })
    })

    // 触摸事件兜底（iOS Safari 常用）
    document.addEventListener('touchstart', (e) => {
      if(manualMode) return;
      const t = e.touches[0] || e.changedTouches[0];
      if(!t) return;
      measuring = true; zeroFrameCount = 0; hint.style.display = 'none';
      const w = (t.radiusX ? t.radiusX * 2 : 0);
      feedSample(t.clientX, t.clientY, w);
      e.preventDefault();
    }, { passive:false });
    document.addEventListener('touchmove', (e) => {
      if(!measuring || manualMode) return;
      const t = e.touches[0] || e.changedTouches[0];
      if(!t) return;
      const w = (t.radiusX ? t.radiusX * 2 : 0);
      feedSample(t.clientX, t.clientY, w);
      e.preventDefault();
    }, { passive:false });
    document.addEventListener('touchend', () => { measuring = false; }, { passive:true });
    document.addEventListener('touchcancel', () => { measuring = false; }, { passive:true });

    // 模式切换（仅手动/触点切换）
    btnMode.addEventListener('click', () => {
      manualMode = !manualMode;
      updateModeUI();
    });
    function updateModeUI(){
      modeText.textContent = manualMode ? '手动' : '触点';
      manualWrap.style.display = manualMode ? 'block' : 'none';
    }

    // ================================
    // 判尺与显示
    // ================================
    function classify(nail){
      const S = store.S, M = store.M, L = store.L;
      const sm = (S + M)/2, ml = (M + L)/2;
      if(nail < sm) return 'S';
      if(nail < ml) return 'M';
      return 'L';
    }

    function updatePill(nail){
      pill.textContent = `${nail.toFixed(1)} mm • 尺码 ${classify(nail)}`;
    }

    // ================================
    // 画尺子
    // ================================
    function drawRuler(nailMM){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // 背景与边框
      roundedRect(ctx, 0.5, 0.5, w-1, h-1, 16);
      ctx.save(); ctx.clip();

      // 基线与中心
      const cx = w/2; const baselineY = 78; // 主刻度基线
      const mmPX = pxPerMM();

      // 带状区 L|M|S|M|L
      const S=store.S, M=store.M, L=store.L;
      const SM=(S+M)/2, ML=(M+L)/2;
      const bands=[
        {from:-999,to:-ML, label:'L', fill:'rgba(255,92,108,.10)'},
        {from:-ML,to:-SM, label:'M', fill:'rgba(241,196,15,.12)'},
        {from:-SM,to:SM,  label:'S', fill:'rgba(58,124,255,.14)'},
        {from:SM, to:ML,  label:'M', fill:'rgba(241,196,15,.12)'},
        {from:ML, to:999, label:'L', fill:'rgba(255,92,108,.10)'}
      ];
      bands.forEach(b => {
        const x1 = cx + b.from*mmPX; const x2 = cx + b.to*mmPX;
        const xL = Math.max(0, Math.min(w, Math.min(x1,x2)));
        const xR = Math.max(0, Math.min(w, Math.max(x1,x2)));
        if(xR<=xL) return;
        ctx.fillStyle = b.fill; ctx.fillRect(xL, baselineY-26, xR-xL, 52);
        // 标签
        ctx.font = '12px system-ui'; ctx.fillStyle = '#9eb0d6';
        const tx = (xL+xR)/2; ctx.textAlign = 'center'; ctx.fillText(b.label, tx, baselineY-32);
      })

      // 刻度
      ctx.strokeStyle = '#30406f'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, baselineY); ctx.lineTo(w, baselineY); ctx.stroke();

      // mm 范围：根据画布宽度
      const rangeMM = Math.ceil(w / (2*mmPX));
      for(let i=-rangeMM;i<=rangeMM;i++){
        const x = cx + i*mmPX;
        const tall = (i%5===0);
        const tH = tall ? 18 : 10;
        ctx.strokeStyle = tall ? '#5c74b1' : '#3a4b83';
        ctx.beginPath();
        ctx.moveTo(x, baselineY);
        ctx.lineTo(x, baselineY - tH);
        ctx.stroke();
        if(tall && i!==0){
          ctx.fillStyle = '#8fa3d9';
          ctx.font = '11px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText((i>0?'+':'') + Math.abs(i), x, baselineY - tH - 4);
        }
      }
      // 中心 0 标签
      ctx.fillStyle = '#c9d7ff'; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('0', cx, baselineY - 22);

      // 当前值高亮（从 0 到 nailMM）
      const x2 = cx + nailMM*mmPX;
      ctx.strokeStyle = '#6aa7ff'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(cx, baselineY+2); ctx.lineTo(x2, baselineY+2); ctx.stroke();
      // 端点竖线
      ctx.strokeStyle = '#8fb8ff'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x2, baselineY+2); ctx.lineTo(x2, baselineY-24); ctx.stroke();

      ctx.restore();
    }

    function roundedRect(c, x,y,w,h,r){
      c.beginPath();
      c.moveTo(x+r, y);
      c.arcTo(x+w, y,   x+w, y+h, r);
      c.arcTo(x+w, y+h, x,   y+h, r);
      c.arcTo(x,   y+h, x,   y,   r);
      c.arcTo(x,   y,   x+w, y,   r);
      c.closePath();
      c.fillStyle = '#0c142d'; c.fill();
      c.strokeStyle = '#1b2550'; c.lineWidth = 1; c.stroke();
    }

    // ================================
    // 主循环
    // ================================
    function tick(){
      
      const mmPX = pxPerMM();

      if(measuring && !manualMode){
        let { w } = lastSample;
        if(!w || w<=0){ zeroFrameCount++; } else { zeroFrameCount = 0; }
        if(zeroFrameCount >= 10){ // 连续多帧为 0，切到手动模式
          manualMode = true; updateModeUI();
        }
        const fingerMM = (w || 0) / mmPX;
        const nailMM = Math.max(0, fingerMM * store.ratio);
        // 中值滤波
        mmQueue.push(nailMM); if(mmQueue.length>smoothN) mmQueue.shift();
        const smoothed = median(mmQueue);
        updatePill(smoothed);
        drawRuler(smoothed);
        }

      if(manualMode){
        // 从把手读像素差
        const rect = manualBar.getBoundingClientRect();
        const left = hLeft.getBoundingClientRect().left - rect.left + 14; // handle center
        const right = hRight.getBoundingClientRect().left - rect.left + 14;
        const px = Math.max(0, right - left);
        const nailMM = px / mmPX;
        updatePill(nailMM);
        drawRuler(nailMM);
      }

      updateModeUI();
      requestAnimationFrame(tick);
    }

    function median(arr){
      if(arr.length===0) return 0;
      const s = [...arr].sort((a,b)=>a-b); const mid = Math.floor(s.length/2);
      return (s.length%2? s[mid] : (s[mid-1]+s[mid])/2);
    }

    // ================================
    // 手动把手拖拽
    // ================================
    function makeDraggable(handle){
      const onDown = (e) => {
        e.preventDefault(); e.stopPropagation();
        const startX = ('touches' in e) ? (e.touches[0]||e.changedTouches[0]).clientX : e.clientX;
        const rect = manualBar.getBoundingClientRect();
        const hRect = handle.getBoundingClientRect();
        const offset = startX - hRect.left;
        const onMove = (ev) => {
          const x = ('touches' in ev) ? (ev.touches[0]||ev.changedTouches[0]).clientX : ev.clientX;
          let left = x - rect.left - offset;
          left = Math.max(-2, Math.min(rect.width-26, left));
          handle.style.left = left + 'px';
          ev.preventDefault();
        }
        const onUp = () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          window.removeEventListener('touchmove', onMove);
          window.removeEventListener('touchend', onUp);
        }
        window.addEventListener('pointermove', onMove, { passive:false });
        window.addEventListener('pointerup', onUp, { passive:true });
        window.addEventListener('touchmove', onMove, { passive:false });
        window.addEventListener('touchend', onUp, { passive:true });
      }
      handle.addEventListener('pointerdown', onDown, { passive:false });
      handle.addEventListener('touchstart', onDown, { passive:false });
    }
    makeDraggable(hLeft); makeDraggable(hRight);

    // ================================
    // 模态框行为
    // ================================
    function openModal(el){ el.classList.add('show'); }
    function closeModal(el){ el.classList.remove('show'); }

    btnCalib.addEventListener('click', ()=> openModal(modalCalib));
    btnRatio.addEventListener('click', ()=> openModal(modalRatio));
    btnRules.addEventListener('click', ()=> openModal(modalRules));

    document.addEventListener('click', (e) => {
      const target = e.target.closest('[data-close]');
      if(target){ const sel = target.getAttribute('data-close'); const el = document.querySelector(sel); el && closeModal(el); }
    })

    // 校准滑杆
    scaleRange.addEventListener('input', () => {
      const v = +scaleRange.value; store.scale = +v.toFixed(2);
      scaleLabel.textContent = store.scale.toFixed(2); updateChips(); updateCardBoxWidth();
    })
    $('#resetScale').addEventListener('click', () => {
      store.scale = 0.83; scaleRange.value = store.scale; scaleLabel.textContent = store.scale.toFixed(2);
      updateChips(); updateCardBoxWidth();
    })

    // 比例滑杆
    ratioRange.addEventListener('input', () => {
      const v = +ratioRange.value; store.ratio = +v.toFixed(2);
      ratioLabel.textContent = store.ratio.toFixed(2); updateChips();
    })

    // 规则输入
    function syncRulesUI(){
      sInput.value = store.S; mInput.value = store.M; lInput.value = store.L;
    }
    sInput.addEventListener('change', () => { store.S = clamp(+sInput.value, 10, 25); syncRulesUI(); })
    mInput.addEventListener('change', () => { store.M = clamp(+mInput.value, 10, 25); syncRulesUI(); })
    lInput.addEventListener('change', () => { store.L = clamp(+lInput.value, 10, 30); syncRulesUI(); })
    $('#resetRules').addEventListener('click', () => { store.S=15; store.M=16; store.L=17; syncRulesUI(); })

    function clamp(v,min,max){ return Math.min(max, Math.max(min, isFinite(v)?v:min)); }

    // ================================
    // 初始化
    // ================================
    function init(){
      refreshPxBase(); resizeCanvas(); updateChips(); syncRulesUI(); updateCardBoxWidth();
      ratioRange.value = store.ratio; ratioLabel.textContent = store.ratio.toFixed(2);
      scaleRange.value = store.scale; scaleLabel.textContent = store.scale.toFixed(2);

      // 设备能力检测（触控）
      const touchCapable = 'ontouchstart' in window || navigator.maxTouchPoints>0;
      if(!touchCapable){ mobileOnly.classList.add('show'); }

      requestAnimationFrame(tick);
    }

    window.addEventListener('resize', () => { resizeCanvas(); updateCardBoxWidth(); })
    window.addEventListener('orientationchange', () => { setTimeout(()=>{ refreshPxBase(); resizeCanvas(); }, 250); })

    init();
  })();
  </script>
</body>
</html>
